import os
import tempfile
import numpy as np
import pandas as pd
import json
from pprint import pprint

#
# setup the env for each exacution
# this allows you to specify a file that contains all the modules you want to have loaded
# for you pipeline.
# the file should be called modules.cfg and should exist in the same locaiton as the snakemake file
#
SNAKEMAKE_DIR = os.path.dirname(workflow.snakefile)
shell.executable("/bin/bash")
shell.prefix("source %s/modules.cfg; set -eo pipefail; " % SNAKEMAKE_DIR)

#
# A little complicated to find the temp dir
# temp dir is a place programs can put tmep files. 
# You will never have to change or think about anything here
#
SSD_TMP_DIR = "/data/scratch/ssd"
if "TMPDIR" in os.environ:
    TMPDIR = os.environ['TMPDIR']
elif "TMPDIR" in config:
    TMPDIR = config['TMPDIR']
elif os.path.exists(SSD_TMP_DIR):
    TMPDIR = SSD_TMP_DIR
else:
    TMPDIR = tempfile.gettempdir()


#
# the config file is where you will have the input to your program, 
# so in your case a reference genome and a fastq file
# you can access things in your config file in this way 
# config["the name of the vraible you want"]
#
configfile: "snake_input.json"


#
# an all rule always is the first rule in a file
# bscially it should have as input the final file you want generated by 
# this porgram
#
rule all:
	input:
		final="orf.vcf",



##########################################################
############# SETUP THE REFERENCE ########################
##########################################################
rule reference_suffix_array:
	input:
		ref = config["ref"],
	output:
		refsa=config["ref"] + ".sa",
	shell:
		"""
		bwa index {input.ref} 
		"""	

rule reference_INDEX:
	input:
		ref = config["ref"],
	output:
		reffai=config["ref"] + ".fai",
	shell:
		"""
		samtools faidx {input.ref} 
		"""
	
########################################################
######### SETUP WILDCARDS FOR INPUT READS ##############
########################################################


#
# we have done this before, this jsut aligns your reads to your reference
#
rule align:
	input:
		ref=config["ref"],
		R1=config["R1"] + "{SAMPLE}_R1.fastq.gz",
		R2=config["R2"] + "{SAMPLE}_R2.fastq.gz",
		refsa=config["ref"] + ".sa",
	output:
		bam=config["outdir"] + "{SAMPLE}.bam",
	shell:
		"""
		bwa mem {input.ref} {input.R1} {input.R2} | \
			samtools view -b -h | \
			samtools sort > {output.bam}
			samtools index {output.bam}
		"""
#
#
#
picard="/net/gs/vol3/software/modules-sw/picard/2.9.0/Linux/RHEL6/x86_64/picard.jar"
rule reference_dict:
	input:
		ref=config["ref"],
	output:
		refdict=os.path.splitext(config["ref"])[0] + ".dict",
	shell:
		"""
		java -d64 -Xmx1g -jar {picard} CreateSequenceDictionary \
			R={input.ref} \
     		O={output.refdict}	
		"""

#
# this is how you run GATK 
#
GATK="/net/gs/vol3/software/modules-sw/GATK/3.7/Linux/RHEL6/x86_64"
rule generateVCF:
	input:
		ref=config["ref"],
		bam=config["reads"] + ".bam",
		reffai=config["ref"] + ".fai",
		refdict=os.path.splitext(config["ref"])[0] + ".dict",
	output:
		vcf="orf.vcf",
	shell:
		"""
		java -d64 -Xmx1g -jar {GATK}/GenomeAnalysisTK.jar\
			-R {input.ref} \
			-T HaplotypeCaller \
			-I {input.bam} \
			-variant_index_type LINEAR \
			-variant_index_parameter 128000 \
			--emitRefConfidence GVCF \
     		-o {output.vcf}	
		"""



